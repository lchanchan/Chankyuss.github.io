---
title : "C++ (13) - 문자열"
excerpt : "문자열에 대하여"

writer: Chankyu Lee
categories: 
  - Cpp
tags:   
  - [C++, Programming, 독학]

toc : true 
toc_sticky: true

date: 2024-02-01
last_modified_at: 2024-02-01
---
*본 내용은 어소트락 무료 강의 [<C/C++ 무료강의>](https://youtube.com/playlist?list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1&si=6MBoz7-uiAULrHoQ "어소트락 게임아카데미 Youtube 재생목록 - C/C++ 무료강의")을 기반으로 공부한 내용을 정리한 것이다. 틀린 내용이 있을 수도 있음.*

# 문자열 (1)
문자를 나타내기 위한 자료형 : char (1), wchar (2) 
표현 방식은 정수형이지만 이를 배열로 선언해보자

wchar 는 문자 하나를 2바이트로 표현하겠다는 뜻.

1바이트 = 8비트이지만 255를 다 쓸수없다. 맨 앞 비트 수가 1을 써야되기 때문에 결과적으로 7비트만 사용해서 0 ~ 127 까지만 사용 떄문에 아스키 코드에도 127까지만 존재

1바이트로 문자를 표현하면 127까지밖에 표현 불가

한글도 각 문자에따라 숫자가 배정되어 있음. 

2바이트면 2^16이므로 한글의 여러 가짓수를 표현할 수 있음.

1바이트에 넣을 때    char c = 'a';
2바이트에 넣을 때    wchar_t wc = L'a';         -> L을 붙혀준다.

문자열도 마찬가지다.

char szChar[10] = "abcdef";
whcar_t szWChar[10] = L"abcdef";        -> L표시가 문자 표현 시 2바이트를 사용한다는 뜻이다.

2바이트에 한 글자씩(a,b,c,d,e,f)씩 들어감 따라서 예제 코드는 10이아니라 6개 (끝에 0포함)을 해줘야 컴파일 에러가 안남

short arrShort[10] = L"abcdef";             -> short는 이렇게 배열 초기화가 안됨!
=> short arrShort[10] = {97, 98,99,100,101,102, ,}; -> short는 이렇게 배열 초기화

배열 초기화는 문자열 자료형에 특화된 char, wchar만 가능하다.
일일히 아스키 코드를 보며 초기화를 할 필요가 없다.

ROM 코드영역 언급했었는데..
재미난걸 보여드림

const wchar_t* pChar = L"abcdef";

포인터?? 뭔가 이상한데.. 이게 왜 됨? 뭔 차이야?

유추할 수 있는점 -> 문자열이 반환하는 것이 "주소값"이였기에 반환할 수 있었다.
문자하나에 2바이트를 차지하는 것을 알 수 있다.

결론 -> 문자열은 어딘가의 주소를 주는 것. 그래서 주소 변수를 통해 그값을 받고 주소를 통해 가보면 그곳에 문자가 있다. 한칸에 2바이트씩 차지하고 있다. 그 문자가 시작되는 a의 시작 주소를 받아왔다는 것. 

그럼 배열은 무슨 의미? 

문자열이 있고, 그것을 충분히 저장할 수 있는 바이트를 준비해놓고 만들어낸 배열로 그 문자를 하나씩 복사해서 옮겨 오는것. 

szWChar[1] = 'z';        -> "배열"의 b가 z로 바뀜.
pChar[1] = 'z';          ->  2바이트로 한칸 이동해 "주소값"의 b를 z로 변경

10 = 11; 은 말이 안되는게 당연하잖아. 마찬가지로 문자열이라는건 내가 작성한 코드 그 자체.

따라서 배열의 초기화 구문이 의미하는 바는 프로그램 실행 시 스택 메모리의 문자를 복사하는 것

포인터는 메인 함수 스택에 포인터 변수가 있고, 작성해놓은 코드 자체가 어딘가에 있을 때, 그곳의 문자 코드 시작 주소를 포인터 변수에 준 것.
실행 도중 변경될 수 없는 공간인 ROM
실행 중에 코드가 변경될 수 있는 프로그램은 존재하지 않는다.
코드 상에 작성 된 문자열은 따로 저장이 되어 있음.

둘의 구분이 중요하다!!
포인터 변수 pChar[1] = 'z'; 주소값을 가르키는 것!!!!

그래서 그 주소값이 변경되지 않도록 const 포인터를 사용하는 것!!

문자열의 반환 타입이 수정할 수 없는 타입이기 떄문에 const 포인터로 맞춰서 받아와야함.

일반 포인터로 강제 캐스팅이 가능하다

떄문에 포인터로 주소의 값을 변경하면 런타임 에러가 발생함. 왜냐면 읽기 전용 영역에 존재하는 주소값을 변경하면 안돼기 때문이다. 그걸 고치려 했으니 오류가 생김.

잘 다룰줄 알아야함. 포인터랑 이해 관계가 많이 연결되어있음.

# 문자열 (2)
