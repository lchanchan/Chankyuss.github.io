---
title : "C++ (2) - 연산자"
excerpt : "산술 / 증감 / 논리 연산자"

writer: Chankyu Lee
categories: 
  - Cpp
tags:   
  - [C++, Programming, 독학]

toc : true 
toc_sticky: true

date: 2024-01-10
last_modified_at: 2024-01-15
---
*본 내용은 어소트락 무료 강의 [C/C++ 무료강의](https://youtube.com/playlist?list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1&si=6MBoz7-uiAULrHoQ "어소트락 게임아카데미 Youtube 재생목록 - C/C++ 무료강의")을 기반으로 공부한 내용을 정리한 것이다. 틀린 내용이 있을 수도 있음.*

# 연산자

다양한 연산자가 존재한다. 우선 **산술 연산자**, **증감 연산자**, **논리 연산자**에 대해 정리한다.

## 산술 연산자

사칙연산을 나타낸다. 나눗셈이 몫을 구하는 것과 나머지를 구하는 것이 나뉘어져 있는 것이 특징.

```cpp
int Data = 10 + 10;
int Data = 10 - 10;
int Data = 10 * 10;
int Data = 10 / 10; // (몫 : 1)
int Data = 10 % 10; // (나머지 : 0)
```

몫이 나누어 떨어지지 않는 변수값일 경우 경고 메시지와 함께 **형변환**이 발생한다. <u>실수값이 정수값이 될 경우 데이터 손실이 발생</u>하기 때문이다.

```cpp
// 정수형 : Data에 대하여
data = 10. / 3. ; // 형변환 발생 (실수 -> 정수) => 소수점 데이터 손실 
data = (int)(10./3.); // 형변환 표기시 경고메시지는 출력 X
```

실수를 상수로 적을 경우 f만 붙이거나 소수점 찍고 뒤에 f를 붙이면 float 자료형, f를 붙이지 않을 경우 double 자료형으로 간주한다. 

나머지를 구하는 연산자(%)를 **모듈러스 연산자**라고 하며, <u>피연산자가 **모두 정수**여야 오류가 나지 않는다.</u>

## 증감 연산자

증감, 즉 증가와 감소의 폭은 일정하진 않지만 1씩 증감한다고 생각한다.
증감 연산자를 통해 산술 연산자로 표현한 코드를 더 간단하게 표현 가능하다.

```cpp
int Data = 10 + 10; => data += 20 // 산술 연산자를 쉽게 표현

// "전위" 와 "후위" 
Data = 0;
Data ++;  ++Data;   // 연산자의 위치에 따라 연산자 우선순위가 달라진다.        
Data --;  --Data; 
```

앞에 위치한 것을 **전위 연산자**, 뒤에 위치한 것을 **후위 연산자** 라고하며, 무엇을 쓰냐에 따라 변수값이 달라진다.

*전위와 후위의 차이 예시 코드*
```cpp
// 1. 후위의 경우    data : 10 
a = 10;
data = a++;     //  data에 a값 대입 => a값 증가 (10 -> 11) 

// 2. 전위의 경우   data : 11
a = 10;
data = ++a;     // a값 증가 (10 -> 11) => data에 증가된 a값 대입 

// ++ => 전위,후위 상관없이 변수 공간의 값을 증가 시킨다.
```

연산자는 **전위**로 사용하는 것이 좋다. 왜냐하면 효율이 별로인 함수를 호출할 가능성이 있기 때문이다. (후에 "***오버로딩***"과 연관)

## 논리 연산자

참(True) & 거짓(False) 두 개의 논리 값을 가지는 **Boolean** 자료형이다.
논리 반전, 논리 곱, 논리 합 개념이 존재한다.

+ 논리 반전 : 논리 '역'이라고도 하며 기호 "!"를 사용한다.
+ 논리 곱 : and의 기능. 기호 "&&"를 사용한다.
+ 논리 합 : or의 기능. 기호 "||"를 사용한다.
- 참 : True. 0이 아닌 값, 즉 "1"
- 거짓 : False. "0"

*논리 반전 예시 코드*

```cpp
int TrueFalse = true; // TrueFalse의 변수값 = 1
int TrueFalse = false; // TrueFalse의 변수값 = 0

bool IsTrue = 100; / // 100이 저장되면 "1"로 받아들인다. (0이 아닌 값이므로)

// 역을 구하기
IsTrue = !IsTrue; // IsTrue = 0
```

이는 Boolean 자료형 뿐만 아니라 일반 정수형에도 적용된다.

```cpp
int iTrue = 100; 
iTrue = !True; 
```

*논리 곱 , 합 예시 코드*

```cpp
iTrue = 100 && 200;     // True
iTrue = 0 || 0;         // False
iTrue = 0 || 200;       // True 
iTrue = 0 && 200;       // False
```

